# Iceberg服务发现系统说明
## 源起
在soc的分布式系统中，功能点往往会切分成多个细小的高内聚的独立服务。服务之间通过RPC的方式合作来完成系统的功能。这样一来，各种类型的服务会越来越多，而且每种类型的服务往往都以集群的方式布署，整个系统中的服务实例的数量就更多。这么一来在增加服务横向收缩或者是增减新的服务类型的时候将会对开发和运维带来巨大的工作量。

解决办法是系统提供服务发现机制。统一的整理整个系统的拓扑结构。通过服务的注册和发现机制来降低服务之间的耦合。

## 实现方法
经过调研，决定采用etcd来做为服务发现基础服务。相较于zookeeper, etcd有以下几个优点：

1. 采用go语言开发，官方提供golang sdk。易于开发
2. 运维和布署更简单

Iceberg采用RESTful风格的接口,正好可以天衣无缝的和etcd的树型存储结构配合。各个服务连接到etcd后，通过订阅者模式来感知系统拓扑的变化。

## 服务体系
![Iceberg服务体系.png](Iceberg服务体系.png)


Iceberg服务体系是一个树形结构，它反映的是RESTful风格的接口组织关系。**除了provider节点外，树中所有的节点都表示一个RESTful接口。**

* provider节点表示它的父节点对应的接口由什么程序实现其功能并提供服务。
provider保存该类型程序的布署情况。有三个子节点：
    - config  Value:是这一类型服务的通用配置
    - name    Value:该类型服务的名称
    - instance  目录节点，它的子节点表示该服务布署的实例
        - 服务实例节点，Key为实例的LISTEN地址(IP:Port); Value为实例在一致性hash环上的hashkey
    -authorization 服务内部方法分级授权
        openapi,app,internal,stream四中等级
gateway在转发请求时，会按接口树层级进行过滤。也就是说，如果在某个层次上设置了禁用，那么它的子节点的所代表的接口也都会被禁用。但是在接口匹配时，会优先匹配层次更深的接口。这么做的目的是为了能最方便的实现服务降级和服务粒度的拆分。关于服务降级非常容易理解，不再多说。

服务粒度的拆分是考虑可以出现这样的情况，随着业务的发展，一个接口节点可能会细分出很多个子节点，这些子节点的所代表的功能大小不一。这种情况下，我们可以用一个新的服务来处理某一个或者某些节点的接口，剩下的节点继续由老的服务来处理。

## 开发效率

* iceberg 集成了grpc 自动生成代码功能。只需定义protobuf语法风格的描述文件，即可生成客户端和服务端代码。提升开发效率和精简代码。