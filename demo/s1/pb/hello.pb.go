// Code generated by ICEBERG protoc-gen-go. DO NOT EDIT EXCEPET SERVER VERSION.
// source: hello.proto

/*
Package hello is a generated protocol buffer package.

It is generated from these files:
	hello.proto

It has these top-level messages:
	HelloRequest
	HelloResponse
*/
package hello

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	"context"
	"iceberg/frame"
	"iceberg/frame/config"
	"iceberg/frame/protocol"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// HelloRequest 请求结构
type HelloRequest struct {
	Name string `protobuf:"bytes,4,opt,name=name" json:"name" xml:"name,omitempty"`
}

func (m *HelloRequest) Reset()                    { *m = HelloRequest{} }
func (m *HelloRequest) String() string            { return proto.CompactTextString(m) }
func (*HelloRequest) ProtoMessage()               {}
func (*HelloRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *HelloRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// HelloResponse 响应结构
type HelloResponse struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message" xml:"message,omitempty"`
}

func (m *HelloResponse) Reset()                    { *m = HelloResponse{} }
func (m *HelloResponse) String() string            { return proto.CompactTextString(m) }
func (*HelloResponse) ProtoMessage()               {}
func (*HelloResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *HelloResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*HelloRequest)(nil), "hello.HelloRequest")
	proto.RegisterType((*HelloResponse)(nil), "hello.HelloResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.

// Client API for S1 service
// iceberg server version,relation to server uri.
var s1Version = frame.SrvVersionName[frame.SV1]

// 设置了 client stream 代表提供给第三方访问的接口
func Third(ctx frame.Context, in *HelloRequest, opts ...frame.CallOption) (*HelloResponse, error) {
	task, err := frame.ReadyTask(ctx, "third", "s1", s1Version, in, opts...)
	if err != nil {
		return nil, err
	}
	back, err := frame.DeliverTo(task)
	if err != nil {
		return nil, err
	}

	var out HelloResponse
	if err := protocol.Unpack(back.GetFormat(), back.GetBody(), &out); err != nil {
		return nil, err
	}
	return &out, nil
}

// 设置了 server stream 代表提供给内网访问的接口，例如OM
func Internal(ctx frame.Context, in *HelloRequest, opts ...frame.CallOption) (*HelloResponse, error) {
	task, err := frame.ReadyTask(ctx, "internal", "s1", s1Version, in, opts...)
	if err != nil {
		return nil, err
	}
	back, err := frame.DeliverTo(task)
	if err != nil {
		return nil, err
	}

	var out HelloResponse
	if err := protocol.Unpack(back.GetFormat(), back.GetBody(), &out); err != nil {
		return nil, err
	}
	return &out, nil
}

// 没有设置stream 代表提供给APP访问的接口
func App(ctx frame.Context, in *HelloRequest, opts ...frame.CallOption) (*HelloResponse, error) {
	task, err := frame.ReadyTask(ctx, "app", "s1", s1Version, in, opts...)
	if err != nil {
		return nil, err
	}
	back, err := frame.DeliverTo(task)
	if err != nil {
		return nil, err
	}

	var out HelloResponse
	if err := protocol.Unpack(back.GetFormat(), back.GetBody(), &out); err != nil {
		return nil, err
	}
	return &out, nil
}

func Timeout(ctx frame.Context, in *HelloRequest, opts ...frame.CallOption) (*HelloResponse, error) {
	task, err := frame.ReadyTask(ctx, "timeout", "s1", s1Version, in, opts...)
	if err != nil {
		return nil, err
	}
	back, err := frame.DeliverTo(task)
	if err != nil {
		return nil, err
	}

	var out HelloResponse
	if err := protocol.Unpack(back.GetFormat(), back.GetBody(), &out); err != nil {
		return nil, err
	}
	return &out, nil
}

// S1Server Server API for Hello service
type S1Server interface {
	Third(c frame.Context) error

	Internal(c frame.Context) error

	App(c frame.Context) error

	Timeout(c frame.Context) error
}

// RegisterS1Server register S1Server with etcd info
func RegisterS1Server(srv S1Server, cfg *config.BaseCfg) {
	frame.RegisterAndServe(&s1ServerDesc, srv, cfg)
}

// s1 server Third handler
func s1ThirdHandler(srv interface{}, ctx frame.Context) error {
	return srv.(S1Server).Third(ctx)
}

// s1 server Internal handler
func s1InternalHandler(srv interface{}, ctx frame.Context) error {
	return srv.(S1Server).Internal(ctx)
}

// s1 server App handler
func s1AppHandler(srv interface{}, ctx frame.Context) error {
	return srv.(S1Server).App(ctx)
}

// s1 server Timeout handler
func s1TimeoutHandler(srv interface{}, ctx frame.Context) error {
	return srv.(S1Server).Timeout(ctx)
}

// s1 server describe
var s1ServerDesc = frame.ServiceDesc{
	Version:     s1Version,
	ServiceName: "S1",
	HandlerType: (*S1Server)(nil),
	Methods: []frame.MethodDesc{
		{
			A:          frame.Openapi,
			MethodName: "third",
			Handler:    s1ThirdHandler,
		},
		{
			A:          frame.Internal,
			MethodName: "internal",
			Handler:    s1InternalHandler,
		},
		{
			A:          frame.App,
			MethodName: "app",
			Handler:    s1AppHandler,
		},
		{
			A:          frame.App,
			MethodName: "timeout",
			Handler:    s1TimeoutHandler,
		},
	},
	ServiceURI: []string{
		"/services/" + s1Version + "/s1",
	},
	Metadata: "hello.S1",
}

func init() { proto.RegisterFile("hello.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 178 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0xce, 0x48, 0xcd, 0xc9,
	0xc9, 0xd7, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x05, 0x73, 0x94, 0x94, 0xb8, 0x78, 0x3c,
	0x40, 0x8c, 0xa0, 0xd4, 0xc2, 0xd2, 0xd4, 0xe2, 0x12, 0x21, 0x21, 0x2e, 0x96, 0xbc, 0xc4, 0xdc,
	0x54, 0x09, 0x16, 0x05, 0x46, 0x0d, 0xce, 0x20, 0x30, 0x5b, 0x49, 0x93, 0x8b, 0x17, 0xaa, 0xa6,
	0xb8, 0x20, 0x3f, 0xaf, 0x38, 0x55, 0x48, 0x82, 0x8b, 0x3d, 0x37, 0xb5, 0xb8, 0x38, 0x31, 0x3d,
	0x55, 0x82, 0x11, 0xac, 0x0e, 0xc6, 0x35, 0x7a, 0xcc, 0xc8, 0xc5, 0x14, 0x6c, 0x28, 0x64, 0xc6,
	0xc5, 0x1a, 0x92, 0x91, 0x59, 0x94, 0x22, 0x24, 0xac, 0x07, 0xb1, 0x13, 0xd9, 0x0e, 0x29, 0x11,
	0x54, 0x41, 0x88, 0xa1, 0x4a, 0x0c, 0x1a, 0x8c, 0x42, 0x96, 0x5c, 0x1c, 0x9e, 0x79, 0x25, 0xa9,
	0x45, 0x79, 0x89, 0x39, 0x24, 0x69, 0x35, 0x60, 0x14, 0x32, 0xe2, 0x62, 0x76, 0x2c, 0x28, 0x20,
	0x49, 0x97, 0x90, 0x19, 0x17, 0x7b, 0x48, 0x66, 0x6e, 0x6a, 0x7e, 0x69, 0x09, 0x49, 0xfa, 0x92,
	0xd8, 0xc0, 0x41, 0x68, 0x0c, 0x08, 0x00, 0x00, 0xff, 0xff, 0x57, 0xf2, 0xa3, 0xc3, 0x51, 0x01,
	0x00, 0x00,
}
